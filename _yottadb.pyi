#################################################################
#                                                               #
# Copyright (c) 2019-2021 Peter Goss All rights reserved.       #
#                                                               #
# Copyright (c) 2019-2021 YottaDB LLC and/or its subsidiaries.  #
# All rights reserved.                                          #
#                                                               #
#   This source code contains the intellectual property         #
#   of its copyright holder(s), and is made available           #
#   under a license.  If you do not know the terms of           #
#   the license, please stop and do not read further.           #
#                                                               #
#################################################################
from typing import Sequence, Optional, Tuple, Callable, Dict

Key = Tuple[bytes, Optional[Sequence[bytes]]]

class YottaDBLockTimeout(Exception): ...
class YDBTimeoutError(Exception): ...

def data(varname: bytes, subsarray: Optional[Sequence[bytes]] = ..., tp_token: int = ...) -> int: ...
def delete(varname: bytes, subsarray: Optional[Sequence[bytes]] = ..., delete_type: int = ..., tp_token: int = ...) -> None: ...
def delete_excel(varnames: Optional[Sequence[bytes]] = ..., tp_token: int = ...) -> None: ...
def get(varname: bytes, subsarray: Optional[Sequence[bytes]] = ..., tp_token: int = ...) -> bytes: ...
def incr(varname: bytes, subsarray: Optional[Sequence[bytes]] = ..., increment: bytes = ..., tp_token: int = ...) -> None: ...
def lock(keys: Optional[Sequence[Key]], timeout_nsec: int = ..., tp_token: int = ...) -> None: ...
def lock_decr(varname: bytes, subsarray: Optional[Sequence[bytes]] = ..., tp_token: int = ...) -> None: ...
def lock_incr(varname: bytes, subsarray: Optional[Sequence[bytes]] = ..., timeout_nsec: int = ..., tp_token: int = ...) -> None: ...
def node_next(varname: bytes, subsarray: Optional[Sequence[bytes]] = ..., tp_token: int = ...) -> Tuple[bytes]: ...
def node_previous(varname: bytes, subsarray: Optional[Sequence[bytes]] = ..., tp_token: int = ...) -> Tuple[bytes]: ...
def set(varname: bytes, subsarray: Optional[Sequence[bytes]] = ..., value: bytes = ..., tp_token: int = ...) -> None: ...
def str2zwr(input: bytes, tp_token: int = ...) -> bytes: ...
def subscript_next(varname: bytes, subsarray: Optional[Sequence[bytes]] = ..., tp_token: int = ...) -> bytes: ...
def subscript_previous(varname: bytes, subsarray: Optional[Sequence[bytes]] = ..., tp_token: int = ...) -> bytes: ...
def tp(callback: Callable, args: Tuple = ..., kwargs: Dict = ..., transid: str = ..., tp_token: int = ...) -> int: ...
def zwr2str(input: bytes, tp_token: int = ...) -> bytes: ...

YDB_DATA_NO_DATA: int = ...
YDB_DATA_HAS_VALUE_NO_TREE: int = ...
YDB_DATA_NO_VALUE_HAS_TREE: int = ...
YDB_DATA_HAS_VALUE_HAS_TREE: int = ...
YDB_DEL_TREE: int = ...
YDB_DEL_NODE: int = ...
YDB_SEVERITY_WARNING: int = ...
YDB_SEVERITY_SUCCESS: int = ...
YDB_SEVERITY_ERROR: int = ...
YDB_SEVERITY_INFORMATIONAL: int = ...
YDB_SEVERITY_FATAL: int = ...
YDB_MAX_IDENT: int = ...
YDB_MAX_NAMES: int = ...
YDB_MAX_STR: int = ...
YDB_MAX_SUBS: int = ...
YDB_MAX_TIME_NSEC: int = ...
YDB_MAX_YDBERR: int = ...
YDB_MAX_ERRORMSG: int = ...
YDB_MIN_YDBERR: int = ...
YDB_OK: int = ...
YDB_INT_MAX: int = ...
YDB_TP_RESTART: int = ...
YDB_TP_ROLLBACK: int = ...
YDB_NOTOK: int = ...
YDB_LOCK_TIMEOUT: int = ...
YDB_NOTTP: int = ...

class YDBError(Exception): ...
class YDBGVUNDEFError(YDBError): ...
class YDBLVUNDEFError(YDBError): ...
class YDBNODEENDError(YDBError): ...
